# CI/CD usando Docker Compose Traefik com TLS + SSL Let's Encrypt + DNS

name: Deploy com Docker Compose

on:
  # Aguarda ci-cd.yml completar antes de fazer deploy
  workflow_run:
    workflows: ["Backend CI/CD (Build & Publish)"]
    types:
      - completed
  # Permite deploy manual
  workflow_dispatch:

# Prevenir m√∫ltiplos deploys simult√¢neos
concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

env:
  NODE_VERSION: '24'
  DOCKER_REGISTRY: docker.io
  IMAGE_NAME: norohim/pro-mata-backend

jobs:
  deploy-prod-compose:
    name: Deploy Production (Docker Compose)
    runs-on: ubuntu-latest
    # S√≥ roda se o workflow anterior foi bem-sucedido (ou se for dispatch manual)
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'main')

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.PROD_EC2_HOST }}
          username: ${{ secrets.PROD_EC2_USER }}
          key: ${{ secrets.PROD_EC2_SSH_KEY }}
          script: |
            set -euo pipefail

            # ========================================
            # AUTO-MIGRATION: Setup antigo ‚Üí Compose unificado
            # ========================================
            if [ -d "$HOME/prod-db" ] && [ ! -d "/opt/promata-backend/.git" ]; then
              echo "üîÑ Setup antigo detectado - migrando automaticamente..."

              # Criar backup
              BACKUP_DIR="$HOME/backup-$(date +%Y%m%d-%H%M%S)"
              mkdir -p "$BACKUP_DIR"
              echo "üì¶ Criando backup em: $BACKUP_DIR"

              # Parar containers antigos
              echo "‚è∏Ô∏è  Parando containers antigos..."
              docker stop backend-prod backend-dev umami metabase prod-postgres dev-postgres umami-db metabase-db 2>/dev/null || true

              # Backup do PostgreSQL prod (bind mount)
              echo "üíæ Backup do PostgreSQL..."
              docker run --rm -v "$HOME/prod-db/data:/source:ro" -v "$BACKUP_DIR:/backup" alpine tar czf /backup/prod-postgres-data.tar.gz -C /source .

              # Criar volume e migrar dados
              echo "üì¶ Criando volume promata-postgres-data..."
              docker volume create promata-postgres-data
              echo "üîÑ Migrando dados..."
              docker run --rm -v "$HOME/prod-db/data:/source:ro" -v promata-postgres-data:/dest alpine sh -c "cp -av /source/. /dest/"

              # Verificar migra√ß√£o
              FILE_COUNT=$(docker run --rm -v promata-postgres-data:/data alpine sh -c "find /data -type f | wc -l")
              echo "‚úÖ Migra√ß√£o completa: $FILE_COUNT arquivos"

              # Remover containers antigos
              echo "üóëÔ∏è  Removendo containers antigos..."
              docker rm -f backend-prod backend-dev umami metabase prod-postgres dev-postgres umami-db metabase-db 2>/dev/null || true

              echo "‚úÖ Migra√ß√£o conclu√≠da! Backup salvo em: $BACKUP_DIR"
            else
              echo "‚ÑπÔ∏è  Migra√ß√£o n√£o necess√°ria ou j√° realizada"
            fi

            # Navegar para diret√≥rio do projeto em /opt (centralizado)
            sudo mkdir -p /opt/promata-backend
            sudo chown $USER:$USER /opt/promata-backend
            cd /opt/promata-backend

            # Fazer pull do reposit√≥rio ou atualizar
            if [ -d ".git" ]; then
              echo "Atualizando reposit√≥rio..."
              git fetch origin
              git reset --hard origin/main
            else
              echo "Reposit√≥rio n√£o encontrado. Recriando..."
              cd /opt
              sudo rm -rf promata-backend
              git clone https://github.com/AGES-Pro-Mata/backend.git promata-backend
              sudo chown -R $USER:$USER promata-backend
              cd promata-backend
            fi

            # Definir defaults para secrets opcionais
            ACME_EMAIL="${{ secrets.ACME_EMAIL }}"
            ACME_EMAIL="${ACME_EMAIL:-admin@promata.com.br}"

            # Criar/atualizar arquivo .env com secrets
            cat > .env.production << EOF
            # Docker - Usar imagem :latest publicada pelo CI/CD (main branch)
            DOCKER_REGISTRY=${{ env.DOCKER_REGISTRY }}
            IMAGE_NAME=${{ env.IMAGE_NAME }}
            IMAGE_TAG=latest
            CONTAINER_NAME=promata-backend

            # Database Prod
            DATABASE_URL=${{ secrets.PROD_DATABASE_URL }}
            POSTGRES_DB=${{ secrets.POSTGRES_DB || 'promata' }}
            POSTGRES_USER=${{ secrets.POSTGRES_USER || 'admin' }}
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}

            # JWT
            JWT_SECRET=${{ secrets.PROD_JWT_SECRET }}
            JWT_EXPIRES_IN=2h

            # AWS
            AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
            AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
            AWS_S3_REGION=${{ vars.AWS_REGION }}
            AWS_S3_BUCKET=${{ secrets.PROD_AWS_S3_BUCKET }}

            # Cloudflare DNS Challenge (para Let's Encrypt TLS)
            CF_API_EMAIL=${{ secrets.CF_API_EMAIL }}
            CF_DNS_API_TOKEN=${{ secrets.CF_DNS_API_TOKEN }}
            ACME_EMAIL=${ACME_EMAIL}

            # Umami Analytics
            UMAMI_DB_USER=${{ secrets.UMAMI_DB_USER || 'umami' }}
            UMAMI_DB_PASSWORD=${{ secrets.UMAMI_DB_PASSWORD || 'umami' }}
            UMAMI_DB_NAME=${{ secrets.UMAMI_DB_NAME || 'umami' }}
            UMAMI_APP_SECRET=${{ secrets.UMAMI_APP_SECRET }}
            UMAMI_URL=${{ secrets.UMAMI_URL || '' }}
            UMAMI_WEBSITE_ID=${{ secrets.UMAMI_WEBSITE_ID || '' }}

            # Metabase
            METABASE_DB_USER=${{ secrets.METABASE_DB_USER || 'metabase' }}
            METABASE_DB_PASSWORD=${{ secrets.METABASE_DB_PASSWORD || 'metabase123' }}
            METABASE_DB_NAME=${{ secrets.METABASE_DB_NAME || 'metabase' }}

            # App
            NODE_ENV=production
            PORT=3000
            EOF

            # Usar .env.production
            cp .env.production .env

            # Pull das imagens mais recentes
            echo "Atualizando imagens Docker..."
            docker compose -p promata-prod -f docker-compose.prod.yml pull

            # Parar servi√ßos
            echo "Parando servi√ßos..."
            docker compose -p promata-prod -f docker-compose.prod.yml down || true

            # Iniciar servi√ßos
            echo "Iniciando servi√ßos..."
            docker compose -p promata-prod -f docker-compose.prod.yml up -d

            # Aguardar servi√ßos subirem
            sleep 15

            # Executar migrations
            echo "Executando migrations..."
            docker compose -p promata-prod -f docker-compose.prod.yml exec -T backend npx prisma migrate deploy || echo "Migrations j√° aplicadas"

            # Verificar status
            echo "Status dos servi√ßos:"
            docker compose -p promata-prod -f docker-compose.prod.yml ps

            # Limpar imagens antigas
            echo "Limpando imagens antigas..."
            docker image prune -af --filter "until=24h" || true

            echo "‚úÖ Deploy conclu√≠do!"

  deploy-dev-compose:
    name: Deploy Development (Docker Compose)
    runs-on: ubuntu-latest
    # S√≥ roda se o workflow anterior foi bem-sucedido na branch dev (ou se for dispatch manual)
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'dev')

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Deploy DEV via SSH
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.DEV_EC2_HOST }}
          username: ${{ secrets.DEV_EC2_USER }}
          key: ${{ secrets.DEV_EC2_SSH_KEY }}
          script: |
            set -euo pipefail

            # Garantir que o diret√≥rio existe e tem as permiss√µes corretas
            sudo mkdir -p /opt/promata-backend-dev
            sudo chown -R $USER:$USER /opt/promata-backend-dev
            cd /opt/promata-backend-dev

            # Fazer pull do reposit√≥rio ou atualizar
            if [ -d ".git" ]; then
              echo "Atualizando reposit√≥rio DEV..."
              git fetch origin
              git reset --hard origin/dev
            else
              echo "Clonando reposit√≥rio DEV..."
              # Limpar diret√≥rio antes de clonar (exceto se j√° tiver .git)
              rm -rf * .[^.]* ..?* 2>/dev/null || true
              git clone -b dev https://github.com/AGES-Pro-Mata/backend.git .
            fi

            # Criar/atualizar arquivo .env.dev com secrets
            cat > .env.dev << EOF
            # Docker - Backend (imagem -dev publicada pelo CI/CD)
            DOCKER_REGISTRY=${{ env.DOCKER_REGISTRY }}
            IMAGE_NAME=${{ env.IMAGE_NAME }}-dev
            IMAGE_TAG=latest
            CONTAINER_NAME=promata-dev-backend

            # Backend Configuration
            NODE_ENV=development
            BACKEND_PORT=3010
            PORT=3010

            # Database Dev (conex√£o interna do Docker)
            DATABASE_URL=postgresql://${{ secrets.DEV_POSTGRES_USER || 'promata' }}:${{ secrets.DEV_POSTGRES_PASSWORD }}@database:5432/${{ secrets.DEV_POSTGRES_DB || 'promata' }}
            POSTGRES_DB=${{ secrets.DEV_POSTGRES_DB || 'promata' }}
            POSTGRES_USER=${{ secrets.DEV_POSTGRES_USER || 'promata' }}
            POSTGRES_PASSWORD=${{ secrets.DEV_POSTGRES_PASSWORD }}
            DATABASE_PORT_MAPPING=5431:5432

            # JWT
            JWT_SECRET=${{ secrets.DEV_JWT_SECRET }}
            JWT_EXPIRES_IN=24h

            # AWS
            AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
            AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
            AWS_S3_REGION=${{ vars.AWS_REGION }}
            AWS_S3_BUCKET=${{ secrets.DEV_AWS_S3_BUCKET }}

            # Analytics (optional for dev)
            UMAMI_URL=${{ secrets.DEV_UMAMI_URL || '' }}
            UMAMI_WEBSITE_ID=${{ secrets.DEV_UMAMI_WEBSITE_ID || '' }}
            EOF

            # Limpar containers antigos de outros diret√≥rios (se existirem)
            echo "Limpando containers antigos..."
            docker ps -a --filter "name=promata-dev" --format "{{.Names}}" | grep -v "^promata-dev-" | xargs -r docker rm -f 2>/dev/null || true

            # Pull das imagens mais recentes
            echo "Atualizando imagens Docker DEV..."
            docker compose -p promata-dev -f docker-compose.dev.yml --env-file .env.dev pull

            # Parar servi√ßos DEV
            echo "Parando servi√ßos DEV..."
            docker compose -p promata-dev -f docker-compose.dev.yml --env-file .env.dev down || true

            # Iniciar servi√ßos DEV
            echo "Iniciando servi√ßos DEV..."
            docker compose -p promata-dev -f docker-compose.dev.yml --env-file .env.dev up -d

            # Aguardar servi√ßos subirem
            sleep 15

            # Executar migrations
            echo "Executando migrations..."
            docker compose -p promata-dev -f docker-compose.dev.yml --env-file .env.dev exec -T backend npx prisma migrate deploy || echo "Migrations j√° aplicadas"

            # Verificar status
            echo "Status dos servi√ßos DEV:"
            docker compose -p promata-dev -f docker-compose.dev.yml --env-file .env.dev ps

            # Limpar imagens antigas
            echo "Limpando imagens antigas..."
            docker image prune -af --filter "until=24h" || true

            echo "‚úÖ Deploy DEV conclu√≠do!"
